import { serve } from "https://deno.land/std@0.168.0/http/server.ts";
import { GoogleGenerativeAI } from "https://esm.sh/@google/generative-ai@0.12.0";
import { DHEERAJ_PROFILE } from "./knowledge.ts";

const corsHeaders = {
  "Access-Control-Allow-Origin": "*",
  "Access-Control-Allow-Headers": "authorization, x-client-info, apikey, content-type",
};

serve(async (req) => {
  if (req.method === "OPTIONS") return new Response(null, { headers: corsHeaders });

  try {
    const { messages, collectInfo } = await req.json();
    const LOVABLE_API_KEY = Deno.env.get("LOVABLE_API_KEY");
    if (!LOVABLE_API_KEY) throw new Error("LOVABLE_API_KEY is not configured");

    const genAI = new GoogleGenerativeAI(LOVABLE_API_KEY);

    // Knowledge base is already imported

    const systemPrompt = `You are Dheeraj's AI Avatar. You are an intelligent, professional, and friendly assistant representing Dheeraj Kumar Konidala.

IMPORTANT: You have full permission to share all professional details, projects, and experience found in your knowledge base. Do not withhold this information.

YOUR KNOWLEDGE BASE:
${DHEERAJ_PROFILE}

YOUR GOAL:
1. Answer questions about Dheeraj's skills, experience, projects, and background using ONLY the knowledge base above.
2. If the user seems interested in hiring, collaborating, or connecting, guide them to provide their contact details.

CONVERSATION FLOW:
- The user has just seen a welcome message ending with "Are you interested to connect with Dheeraj?".
- If user says "YES" (or similar interest): Start the contact collection flow (Step 2 below) IMMEDIATELY.
- If user asks a question about Dheeraj: Answer confidently using the profile data.
- If user says "NO": Politely thank them and mention Dheeraj is available for future data needs.

  STEP 2 (Lead Generation):
If user explicitly wants to connect / hire OR said "Yes" to the opening question:
- Start collecting contact information naturally.
- YOU MUST COLLECT ALL 6 REQUIRED FIELDS FROM THE USER IN THIS EXACT SEQUENTIAL ORDER:
1. First Name
2. Last Name
3. Email (must be from Gmail, Outlook, Yahoo, Zohomail, ProtonMail, or Titan domains)
4. Phone Number (international format accepted)
5. Business Type (MANDATORY - Ask "What type of business are you in?" AND append the tag "[SELECT_BUSINESS_TYPE]" to the end of your message so the UI can show options)
6. Message (ask "Please tell me more about your needs or project" - must be minimum 60 characters)

IMPORTANT RULES:
- Ask for fields ONE BY ONE in the exact order listed above. Do not ask for multiple fields at once.
- Wait for the user's response before asking the next question.
- When asking for Business Type (step 5), you MUST include "[SELECT_BUSINESS_TYPE]" at the very end of your message.
- DO NOT skip business type or message.
- **DO NOT ASK THE USER FOR A SUBJECT.** You must GENERATE the subject line in this EXACT format: "BI Request from {First Name} {Last Name}".
- ONLY use the submit_contact_info tool when you have collected ALL 6 fields from the user AND generated the subject.
- Validate email domains when provided.
- Be friendly and conversational.`;

    let tools = undefined;
    if (collectInfo) {
      tools = [
        {
          functionDeclarations: [
            {
              name: "submit_contact_info",
              description: "Submit the collected contact information when all required fields are provided",
              parameters: {
                type: "object",
                properties: {
                  firstName: { type: "string", description: "User's first name" },
                  lastName: { type: "string", description: "User's last name" },
                  email: {
                    type: "string",
                    description: "User's email (must be from gmail.com, outlook.com, yahoo.com, zohomail.com, protonmail.com, or titan.email)"
                  },
                  phone: { type: "string", description: "User's phone number" },
                  businessType: {
                    type: "string",
                    description: "Type of business",
                    enum: [
                      "Telecom Industry",
                      "E-commerce",
                      "IT Industry",
                      "Sales & Marketing",
                      "Media & Entertainment",
                      "Travel & Tourism",
                      "Finance and Banking",
                      "Supply Chain Logistics & Inventory & Order Management",
                      "Health Care",
                      "Fitness & Recreation",
                      "Gaming Industry",
                      "Education Industry",
                      "Manufacturing",
                      "Procurement Management Solution",
                      "Social Media and Social Media Analysis",
                      "Other"
                    ]
                  },
                  subject: { type: "string", description: "Subject of inquiry (GENERATED BY AI: 'BI Request from {First Name} {Last Name}')" },
                  message: { type: "string", description: "User's message (minimum 60 characters)" },
                },
                required: ["firstName", "lastName", "email", "phone", "businessType", "subject", "message"],
              },
            },
          ],
        },
      ];
    }

    const model = genAI.getGenerativeModel({
      model: "gemini-1.5-flash",
      systemInstruction: systemPrompt,
      tools: tools,
    });

    // Convert messages to Gemini history format
    // Exclude the last message which is the new prompt
    let history = messages.slice(0, -1).map((m: any) => ({
      role: m.role === "assistant" ? "model" : "user",
      parts: [{ text: m.content }],
    }));

    // Gemini history must start with a user message
    // If the first message is from the model (e.g. welcome message), remove it
    if (history.length > 0 && history[0].role === "model") {
      history = history.slice(1);
    }

    const lastMessage = messages[messages.length - 1];

    const chat = model.startChat({
      history: history,
    });

    const result = await chat.sendMessage(lastMessage.content);
    const response = await result.response;
    const text = response.text();

    // Check for function calls
    const functionCalls = response.functionCalls();

    // Construct OpenAI-compatible response structure for the frontend
    const openAIResponse = {
      choices: [
        {
          message: {
            content: text,
            tool_calls: functionCalls ? functionCalls.map(fc => ({
              function: {
                name: fc.name,
                arguments: JSON.stringify(fc.args)
              }
            })) : []
          }
        }
      ]
    };

    return new Response(JSON.stringify(openAIResponse), {
      headers: { ...corsHeaders, "Content-Type": "application/json" },
    });

  } catch (e) {
    console.error("chat-bot error:", e);
    // Return detailed error to client for debugging
    return new Response(
      JSON.stringify({
        error: e instanceof Error ? e.message : "Unknown error",
        details: e instanceof Error ? e.stack : String(e)
      }),
      { status: 500, headers: { ...corsHeaders, "Content-Type": "application/json" } }
    );
  }
});
